{"/home/travis/build/npmtest/node-npmtest-cordova.plugins.diagnostic/test.js":"/* istanbul instrument in package npmtest_cordova_plugins_diagnostic */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova.plugins.diagnostic/lib.npmtest_cordova.plugins.diagnostic.js":"/* istanbul instrument in package npmtest_cordova_plugins_diagnostic */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cordova_plugins_diagnostic = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cordova_plugins_diagnostic = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova.plugins.diagnostic/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cordova.plugins.diagnostic && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cordova_plugins_diagnostic */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cordova_plugins_diagnostic\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cordova_plugins_diagnostic.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_cordova_plugins_diagnostic.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cordova_plugins_diagnostic.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_cordova_plugins_diagnostic.__dirname + '/lib.npmtest_cordova_plugins_diagnostic.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova.plugins.diagnostic/node_modules/cordova.plugins.diagnostic/src/windows/diagnosticProxy.js":"/**\r\n *  Diagnostic plugin for Windows 10 Universal\r\n *\r\n *  Copyright (c) 2015 Next Wave Software, Inc.\r\n**/\r\ncordova.commandProxy.add(\"Diagnostic\", {\r\n\r\n    /**\r\n     * Checks if location is enabled.\r\n     *\r\n     * @param {Function} successCallback - The callback which will be called when diagnostic is successful. \r\n     * This callback function is passed a single boolean parameter with the diagnostic result.\r\n     * @param {Function} errorCallback -  The callback which will be called when diagnostic encounters an error.\r\n     *  This callback function is passed a single string parameter containing the error message.\r\n     */\r\n    // exec(win, fail, 'Diagnostic', 'isLocationAvailable', []);\r\n    isLocationAvailable: function (successCallback, errorCallback) {\r\n\r\n        Windows.Devices.Geolocation.Geolocator.requestAccessAsync().done(\r\n            function (accessStatus) {\r\n                var isEnabled = false;\r\n                var isError = false;\r\n                switch (accessStatus) {\r\n                    case Windows.Devices.Geolocation.GeolocationAccessStatus.allowed:\r\n                        isEnabled = true;\r\n                        break;\r\n                    case Windows.Devices.Geolocation.GeolocationAccessStatus.denied:\r\n                        isEnabled = false;\r\n                        break;\r\n                    case Windows.Devices.Geolocation.GeolocationAccessStatus.unspecified:\r\n                        isError = true;\r\n                        break;\r\n                }\r\n                if (!isError)\r\n                    successCallback(isEnabled);\r\n                else\r\n                    errorCallback(\"Unspecified error\");\r\n            },\r\n            function (error) {\r\n                errorCallback(error);\r\n            }\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Checks if bluetooth/wifi is enabled.\r\n     *\r\n     * @param {Function} successCallback - The callback which will be called when diagnostic is successful. \r\n     * This callback function is passed a single boolean parameter with the diagnostic result.\r\n     * @param {Function} errorCallback -  The callback which will be called when diagnostic encounters an error.\r\n     *  This callback function is passed a single string parameter containing the error message.\r\n     * @param {String} radioToCheck - \"bluetooth\" or \"wifi\".\r\n     */\r\n    // exec(win, fail, 'Diagnostic', 'isRadioEnabled', [bluetooth/wifi]);\r\n    isRadioEnabled: function (successCallback, errorCallback, radioToCheck) {\r\n\r\n        Windows.Devices.Radios.Radio.getRadiosAsync().done(\r\n            function (radioList) {\r\n                var radioKind = (radioToCheck == \"bluetooth\") ? Windows.Devices.Radios.RadioKind.bluetooth : Windows.Devices.Radios.RadioKind.wiFi;\r\n                var isEnabled = false;\r\n                for (var i = 0; i < radioList.length; i++) {\r\n                    if ((radioList[i].kind == radioKind)\r\n                        && (radioList[i].state == Windows.Devices.Radios.RadioState.on)) {\r\n                        isEnabled = true;\r\n                        break;\r\n                    }\r\n                }\r\n                successCallback(isEnabled);\r\n            },\r\n            function (error) {\r\n                errorCallback(error);\r\n            }\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Checks if camera is enabled.\r\n     *\r\n     * @param {Function} successCallback - The callback which will be called when diagnostic is successful. \r\n     * This callback function is passed a single boolean parameter with the diagnostic result.\r\n     * @param {Function} errorCallback -  The callback which will be called when diagnostic encounters an error.\r\n     *  This callback function is passed a single string parameter containing the error message.\r\n     */\r\n    // exec(win, fail, 'Diagnostic', 'isCameraAvailable', []);\r\n    isCameraAvailable: function (successCallback, errorCallback) {\r\n\r\n        Windows.Devices.Enumeration.DeviceInformation.findAllAsync(Windows.Devices.Enumeration.DeviceClass.videoCapture).then(\r\n            function (deviceList) {\r\n                var isEnabled = false;\r\n                for (var i = 0; i < deviceList.length; i++) {\r\n                    if ((deviceList[i].enclosureLocation != null) && (deviceList[i].enclosureLocation.panel === Windows.Devices.Enumeration.Panel.back)) {\r\n                        isEnabled = true;\r\n                        break;\r\n                    }\r\n                }\r\n                successCallback(isEnabled);\r\n            },\r\n            function (error) {\r\n                errorCallback(error);\r\n            }\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Display the location services settings page.\r\n     */\r\n    // exec(null, null, 'Diagnostic', 'switchToLocationSettings', []);\r\n    switchToLocationSettings: function () {\r\n\r\n        var uri = new Windows.Foundation.Uri(\"ms-settings:privacy-location\");\r\n        Windows.System.Launcher.launchUriAsync(uri);\r\n    },\r\n\r\n    /**\r\n     * Display the mobile data settings page.\r\n     */\r\n    // exec(null, null, 'Diagnostic', 'switchToMobileDataSettings', []);\r\n    switchToMobileDataSettings: function () {\r\n\r\n        var uri = new Windows.Foundation.Uri(\"ms-settings:datausage\");\r\n        Windows.System.Launcher.launchUriAsync(uri);\r\n    },\r\n\r\n    /**\r\n     * Display the wifi settings page.\r\n     */\r\n    // exec(null, null, 'Diagnostic', 'switchToWifiSettings', []);\r\n    switchToWifiSettings: function () {\r\n\r\n        var uri = new Windows.Foundation.Uri(\"ms-settings-wifi:\");\r\n        Windows.System.Launcher.launchUriAsync(uri);\r\n    },\r\n\r\n    /**\r\n     * Display the bluetooth settings page.\r\n     */\r\n    // exec(null, null, 'Diagnostic', 'switchToBluetoothSettings', []);\r\n    switchToBluetoothSettings: function () {\r\n\r\n        // Mike says: According to the docs, \"ms-settings-bluetooth:\" is the correct URI to use\r\n        // to take the user directly to the Bluetooth page in the mobile settings app, but as of 10/9/2015\r\n        // it does not work (we just get back \"false\" in the success callback). So,\r\n        // using the desktop settings URI until this gets fixed, which takes the user to the\r\n        // \"which of these settings are you interested in?\" page.\r\n        var uri = new Windows.Foundation.Uri(\"ms-settings:bluetooth\");\r\n        Windows.System.Launcher.launchUriAsync(uri);\r\n    },\r\n\r\n    /**\r\n     * Enables/disables WiFi or Bluetooth on the device.\r\n     *\r\n     * @param {Function} successCallback - function to call on successful setting of radio state\r\n     * @param {Function} errorCallback - function to call on failure to set radio state.\r\n     * This callback function is passed a single string parameter containing the error message.\r\n     * @param {String} radioToSet - \"bluetooth\" or \"wifi\".\r\n     * @param {Boolean} state - WiFi state to set: TRUE for enabled, FALSE for disabled.\r\n     */\r\n    // exec(win, fil, 'Diagnostic', 'setRadioState', [bluetooth/wifi, true/false]);\r\n    setRadioState: function (successCallback, errorCallback, args) {\r\n\r\n        var radioToSet = args[0];\r\n        var state = args[1];\r\n\r\n        // Check the return code from Radio.requestAccessAsync() and Radio.setStateAsync() \r\n        // calls below, return \"Ok\" if successful, error message if not.\r\n        function checkRadioAccessError(accessStatus) {\r\n            var msgOut = \"\";\r\n            switch (accessStatus) {\r\n                case Windows.Devices.Radios.RadioAccessStatus.allowed:\r\n                    msgOut = \"Ok\";\r\n                    break;\r\n                case Windows.Devices.Radios.RadioAccessStatus.deniedByUser:\r\n                    msgOut = \"Access denied by user\";\r\n                    break;\r\n                case Windows.Devices.Radios.RadioAccessStatus.deniedBySystem:\r\n                    msgOut = \"Access denied by system\";\r\n                    break;\r\n                case Windows.Devices.Radios.RadioAccessStatus.unspecified:\r\n                default:\r\n                    msgOut = \"Access denied, unspecified reason\";\r\n                    break;\r\n            }\r\n            return (msgOut);\r\n        }\r\n\r\n        // Get the requested radio\r\n        var radioKind = (radioToSet == \"bluetooth\") ? Windows.Devices.Radios.RadioKind.bluetooth : Windows.Devices.Radios.RadioKind.wiFi;\r\n        Windows.Devices.Radios.Radio.getRadiosAsync().done(\r\n            function (radioList) {\r\n                var radio = null;\r\n                for (var i = 0; i < radioList.length; i++) {\r\n                    if (radioList[i].kind == radioKind) {\r\n                        radio = radioList[i];\r\n                        break;\r\n                    }\r\n                }\r\n                if (radio == null) {\r\n                    errorCallback(\"Device not found\");\r\n                    return;\r\n                }\r\n\r\n                // Get access to the radio\r\n                Windows.Devices.Radios.Radio.requestAccessAsync().done(\r\n                    function (accessStatus) {\r\n                        var resultMsg = checkRadioAccessError(accessStatus);\r\n                        if (resultMsg != \"Ok\") {\r\n                            errorCallback(resultMsg);\r\n                            return;\r\n                        }\r\n\r\n                        // Set the state of the radio\r\n                        var radioState = (state) ? Windows.Devices.Radios.RadioState.on : Windows.Devices.Radios.RadioState.off;\r\n                        radio.setStateAsync(radioState).done(\r\n                            function (accessStatus) {\r\n                                var resultMsg = checkRadioAccessError(accessStatus);\r\n                                if (resultMsg == \"Ok\")\r\n                                    successCallback();\r\n                                else\r\n                                    errorCallback(resultMsg);\r\n                            },\r\n                            function (error) {\r\n                                errorCallback(error);\r\n                            }\r\n                        );\r\n                    },\r\n                    function (error) {\r\n                        errorCallback(error);\r\n                    }\r\n                );\r\n            },\r\n            function (error) {\r\n                errorCallback(error);\r\n            }\r\n        );\r\n    }\r\n});\r\n","/home/travis/build/npmtest/node-npmtest-cordova.plugins.diagnostic/node_modules/cordova.plugins.diagnostic/www/android/diagnostic.js":"/**\n *  Diagnostic plugin for Android\n *\n *  Copyright (c) 2015 Working Edge Ltd.\n *  Copyright (c) 2012 AVANTIC ESTUDIO DE INGENIEROS\n **/\nvar Diagnostic = (function(){\n\n    /***********************\n     *\n     * Internal properties\n     *\n     *********************/\n    var Diagnostic = {};\n\n    var runtimeStoragePrefix = \"__diag_rtm_\";\n\n    var runtimeGroupsMap;\n\n    // Indicates if a runtime permissions request is in progress\n    var requestInProgress = false;\n\n    /********************\n     *\n     * Public properties\n     *\n     ********************/\n\n    // Placeholder listeners\n    Diagnostic._onBluetoothStateChange =\n        Diagnostic._onLocationStateChange =\n            Diagnostic._onNFCStateChange =\n                Diagnostic._onPermissionRequestComplete = function(){};\n\n\n    /**\n     * \"Dangerous\" permissions that need to be requested at run-time (Android 6.0/API 23 and above)\n     * See http://developer.android.com/guide/topics/security/permissions.html#perm-groups\n     * @type {Object}\n     */\n    Diagnostic.runtimePermission = // deprecated\n        Diagnostic.permission = {\n            \"READ_CALENDAR\": \"READ_CALENDAR\",\n            \"WRITE_CALENDAR\": \"WRITE_CALENDAR\",\n            \"CAMERA\": \"CAMERA\",\n            \"READ_CONTACTS\": \"READ_CONTACTS\",\n            \"WRITE_CONTACTS\": \"WRITE_CONTACTS\",\n            \"GET_ACCOUNTS\": \"GET_ACCOUNTS\",\n            \"ACCESS_FINE_LOCATION\": \"ACCESS_FINE_LOCATION\",\n            \"ACCESS_COARSE_LOCATION\": \"ACCESS_COARSE_LOCATION\",\n            \"RECORD_AUDIO\": \"RECORD_AUDIO\",\n            \"READ_PHONE_STATE\": \"READ_PHONE_STATE\",\n            \"CALL_PHONE\": \"CALL_PHONE\",\n            \"ADD_VOICEMAIL\": \"ADD_VOICEMAIL\",\n            \"USE_SIP\": \"USE_SIP\",\n            \"PROCESS_OUTGOING_CALLS\": \"PROCESS_OUTGOING_CALLS\",\n            \"READ_CALL_LOG\": \"READ_CALL_LOG\",\n            \"WRITE_CALL_LOG\": \"WRITE_CALL_LOG\",\n            \"SEND_SMS\": \"SEND_SMS\",\n            \"RECEIVE_SMS\": \"RECEIVE_SMS\",\n            \"READ_SMS\": \"READ_SMS\",\n            \"RECEIVE_WAP_PUSH\": \"RECEIVE_WAP_PUSH\",\n            \"RECEIVE_MMS\": \"RECEIVE_MMS\",\n            \"WRITE_EXTERNAL_STORAGE\": \"WRITE_EXTERNAL_STORAGE\",\n            \"READ_EXTERNAL_STORAGE\": \"READ_EXTERNAL_STORAGE\",\n            \"BODY_SENSORS\": \"BODY_SENSORS\"\n        };\n\n    /**\n     * Permission groups indicate which associated permissions will also be requested if a given permission is requested.\n     * See http://developer.android.com/guide/topics/security/permissions.html#perm-groups\n     * @type {Object}\n     */\n    Diagnostic.runtimePermissionGroups = // deprecated\n        Diagnostic.permissionGroups = {\n            \"CALENDAR\": [\"READ_CALENDAR\", \"WRITE_CALENDAR\"],\n            \"CAMERA\": [\"CAMERA\"],\n            \"CONTACTS\": [\"READ_CONTACTS\", \"WRITE_CONTACTS\", \"GET_ACCOUNTS\"],\n            \"LOCATION\": [\"ACCESS_FINE_LOCATION\", \"ACCESS_COARSE_LOCATION\"],\n            \"MICROPHONE\": [\"RECORD_AUDIO\"],\n            \"PHONE\": [\"READ_PHONE_STATE\", \"CALL_PHONE\", \"ADD_VOICEMAIL\", \"USE_SIP\", \"PROCESS_OUTGOING_CALLS\", \"READ_CALL_LOG\", \"WRITE_CALL_LOG\"],\n            \"SENSORS\": [\"BODY_SENSORS\"],\n            \"SMS\": [\"SEND_SMS\", \"RECEIVE_SMS\", \"READ_SMS\", \"RECEIVE_WAP_PUSH\", \"RECEIVE_MMS\"],\n            \"STORAGE\": [\"READ_EXTERNAL_STORAGE\", \"WRITE_EXTERNAL_STORAGE\"]\n        };\n\n    Diagnostic.runtimePermissionStatus = // deprecated\n        Diagnostic.permissionStatus = {\n            \"GRANTED\": \"GRANTED\", //  User granted access to this permission, the device is running Android 5.x or below, or the app is built with API 22 or below.\n            \"DENIED\": \"DENIED\", // User denied access to this permission\n            \"NOT_REQUESTED\": \"NOT_REQUESTED\", // App has not yet requested access to this permission.\n            \"DENIED_ALWAYS\": \"DENIED_ALWAYS\" // User denied access to this permission and checked \"Never Ask Again\" box.\n        };\n\n    Diagnostic.locationMode = {\n        \"HIGH_ACCURACY\": \"high_accuracy\",\n        \"DEVICE_ONLY\": \"device_only\",\n        \"BATTERY_SAVING\": \"battery_saving\",\n        \"LOCATION_OFF\": \"location_off\"\n    };\n\n    Diagnostic.locationAuthorizationMode = {}; // Empty object to enable easy cross-platform compatibility with iOS\n\n\n    Diagnostic.firstRequestedPermissions;\n\n    Diagnostic.bluetoothState = {\n        \"UNKNOWN\": \"unknown\",\n        \"POWERED_OFF\": \"powered_off\",\n        \"POWERED_ON\": \"powered_on\",\n        \"POWERING_OFF\": \"powering_off\",\n        \"POWERING_ON\": \"powering_on\"\n    };\n\n    Diagnostic.NFCState = {\n        \"UNKNOWN\": \"unknown\",\n        \"POWERED_OFF\": \"powered_off\",\n        \"POWERING_ON\": \"powering_on\",\n        \"POWERED_ON\": \"powered_on\",\n        \"POWERING_OFF\": \"powering_off\"\n    };\n\n\n    /********************\n     *\n     * Internal functions\n     *\n     ********************/\n\n    function checkForInvalidPermissions(permissions, errorCallback){\n        if(typeof(permissions) !== \"object\") permissions = [permissions];\n        var valid = true, invalidPermissions = [];\n        permissions.forEach(function(permission){\n            if(!Diagnostic.permission[permission]){\n                invalidPermissions.push(permission);\n            }\n        });\n        if(invalidPermissions.length > 0){\n            errorCallback(\"Invalid permissions specified: \"+invalidPermissions.join(\", \"));\n            valid = false;\n        }\n        return valid;\n    }\n\n    /**\n     * Maintains a locally persisted list of which permissions have been requested in order to resolve the returned status of STATUS_NOT_REQUESTED_OR_DENIED_ALWAYS to either NOT_REQUESTED or DENIED_ALWAYS.\n     * Since requesting a given permission implicitly requests all other permissions in the same group (e.g. requesting READ_CALENDAR will also grant/deny WRITE_CALENDAR),\n     * flag every permission in the groups that were requested.\n     * @param {Array} permissions - list of requested permissions\n     */\n    function updateFirstRequestedPermissions(permissions){\n        var groups = {};\n\n        permissions.forEach(function(permission){\n            groups[runtimeGroupsMap[permission]] = 1;\n        });\n\n\n        for(var group in groups){\n            Diagnostic.permissionGroups[group].forEach(function(permission){\n                if(!Diagnostic.firstRequestedPermissions[permission]){\n                    setPermissionFirstRequested(permission);\n                }\n            });\n        }\n    }\n\n    function setPermissionFirstRequested(permission){\n        localStorage.setItem(runtimeStoragePrefix+permission, 1);\n        getFirstRequestedPermissions();\n    }\n\n    function getFirstRequestedPermissions(){\n        if(!runtimeGroupsMap){\n            buildRuntimeGroupsMap();\n        }\n        Diagnostic.firstRequestedPermissions = {};\n        for(var permission in Diagnostic.permission){\n            if(localStorage.getItem(runtimeStoragePrefix+permission) == 1){\n                Diagnostic.firstRequestedPermissions[permission] = 1;\n            }\n        }\n        return Diagnostic.firstRequestedPermissions;\n    }\n\n    function resolveStatus(permission, status){\n        if(status == \"STATUS_NOT_REQUESTED_OR_DENIED_ALWAYS\"){\n            status = Diagnostic.firstRequestedPermissions[permission] ? Diagnostic.permissionStatus.DENIED_ALWAYS : Diagnostic.permissionStatus.NOT_REQUESTED;\n        }\n        return status;\n    }\n\n    function buildRuntimeGroupsMap(){\n        runtimeGroupsMap = {};\n        for(var group in Diagnostic.permissionGroups){\n            var permissions = Diagnostic.permissionGroups[group];\n            for(var i=0; i<permissions.length; i++){\n                runtimeGroupsMap[permissions[i]] = group;\n            }\n        }\n    }\n\n    function combineLocationStatuses(statuses){\n        var coarseStatus = statuses[Diagnostic.permission.ACCESS_COARSE_LOCATION],\n            fineStatus = statuses[Diagnostic.permission.ACCESS_FINE_LOCATION],\n            status;\n\n        if(coarseStatus == Diagnostic.permissionStatus.DENIED_ALWAYS || fineStatus == Diagnostic.permissionStatus.DENIED_ALWAYS){\n            status = Diagnostic.permissionStatus.DENIED_ALWAYS;\n        }else if(coarseStatus == Diagnostic.permissionStatus.DENIED || fineStatus == Diagnostic.permissionStatus.DENIED){\n            status = Diagnostic.permissionStatus.DENIED;\n        }else if(coarseStatus == Diagnostic.permissionStatus.NOT_REQUESTED || fineStatus == Diagnostic.permissionStatus.NOT_REQUESTED){\n            status = Diagnostic.permissionStatus.NOT_REQUESTED;\n        }else{\n            status = Diagnostic.permissionStatus.GRANTED;\n        }\n        return status;\n    }\n\n    function combineCameraStatuses(statuses){\n        var cameraStatus = statuses[Diagnostic.permission.CAMERA],\n            mediaStatus = statuses[Diagnostic.permission.READ_EXTERNAL_STORAGE],\n            status;\n\n        if(cameraStatus == Diagnostic.permissionStatus.DENIED_ALWAYS || mediaStatus == Diagnostic.permissionStatus.DENIED_ALWAYS){\n            status = Diagnostic.permissionStatus.DENIED_ALWAYS;\n        }else if(cameraStatus == Diagnostic.permissionStatus.DENIED || mediaStatus == Diagnostic.permissionStatus.DENIED){\n            status = Diagnostic.permissionStatus.DENIED;\n        }else if(cameraStatus == Diagnostic.permissionStatus.NOT_REQUESTED || mediaStatus == Diagnostic.permissionStatus.NOT_REQUESTED){\n            status = Diagnostic.permissionStatus.NOT_REQUESTED;\n        }else{\n            status = Diagnostic.permissionStatus.GRANTED;\n        }\n        return status;\n    }\n\n    function ensureBoolean(callback){\n        return function(result){\n            callback(!!result);\n        }\n    }\n\n    function numberOfKeys(obj){\n        var count = 0;\n        for(var k in obj){\n            count++;\n        }\n        return count;\n    }\n\n\n    /**********************\n     *\n     * Public API functions\n     *\n     **********************/\n\n\n    /***********\n     * General\n     ***********/\n\n    /**\n     * Opens settings page for this app.\n     *\n     * @param {Function} successCallback - The callback which will be called when switch to settings is successful.\n     * @param {Function} errorCallback - The callback which will be called when switch to settings encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.switchToSettings = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'switchToSettings',\n            []);\n    };\n\n    /**\n     * Returns the current authorisation status for a given permission.\n     * Note: this is intended for Android 6 / API 23 and above. Calling on Android 5 / API 22 and below will always return GRANTED status as permissions are already granted at installation time.\n     *\n     * @param {Function} successCallback - function to call on successful retrieval of status.\n     * This callback function is passed a single string parameter which defines the current authorisation status as a value in cordova.plugins.diagnostic.permissionStatus.\n     * @param {Function} errorCallback - function to call on failure to retrieve authorisation status.\n     * This callback function is passed a single string parameter containing the error message.\n     * @param {String} permission - permission to request authorisation status for, defined as a value in cordova.plugins.diagnostic.permission\n     */\n    Diagnostic.getPermissionAuthorizationStatus = function(successCallback, errorCallback, permission){\n        if(!checkForInvalidPermissions(permission, errorCallback)) return;\n\n        function onSuccess(status){\n            successCallback(resolveStatus(permission, status));\n        }\n\n        return cordova.exec(\n            onSuccess,\n            errorCallback,\n            'Diagnostic',\n            'getPermissionAuthorizationStatus',\n            [permission]);\n    };\n\n    /**\n     * Returns the current authorisation status for multiple permissions.\n     * Note: this is intended for Android 6 / API 23 and above. Calling on Android 5 / API 22 and below will always return GRANTED status as permissions are already granted at installation time.\n     *\n     * @param {Function} successCallback - function to call on successful retrieval of status.\n     * This callback function is passed a single object parameter which defines a key/value map, where the key is the requested permission defined as a value in cordova.plugins.diagnostic.permission, and the value is the current authorisation status of that permission as a value in cordova.plugins.diagnostic.permissionStatus.\n     * @param {Function} errorCallback - function to call on failure to retrieve authorisation statuses.\n     * This callback function is passed a single string parameter containing the error message.\n     * @param {Array} permissions - list of permissions to request authorisation statuses for, defined as values in cordova.plugins.diagnostic.permission\n     */\n    Diagnostic.getPermissionsAuthorizationStatus = function(successCallback, errorCallback, permissions){\n        if(!checkForInvalidPermissions(permissions, errorCallback)) return;\n\n        function onSuccess(statuses){\n            for(var permission in statuses){\n                statuses[permission] = resolveStatus(permission, statuses[permission]);\n            }\n            successCallback(statuses);\n        }\n\n        return cordova.exec(\n            onSuccess,\n            errorCallback,\n            'Diagnostic',\n            'getPermissionsAuthorizationStatus',\n            [permissions]);\n    };\n\n\n    /**\n     * Requests app to be granted authorisation for a runtime permission.\n     * Note: this is intended for Android 6 / API 23 and above. Calling on Android 5 / API 22 and below will have no effect as the permissions are already granted at installation time.\n     *\n     * @param {Function} successCallback - function to call on successful request for runtime permission.\n     * This callback function is passed a single string parameter which defines the resulting authorisation status as a value in cordova.plugins.diagnostic.permissionStatus.\n     * @param {Function} errorCallback - function to call on failure to request authorisation.\n     * This callback function is passed a single string parameter containing the error message.\n     * @param {String} permission - permission to request authorisation for, defined as a value in cordova.plugins.diagnostic.permission\n     */\n    Diagnostic.requestRuntimePermission = function(successCallback, errorCallback, permission) {\n        if(!checkForInvalidPermissions(permission, errorCallback)) return;\n\n        if(requestInProgress){\n            return onError(\"A runtime permissions request is already in progress\");\n        }\n\n        function onSuccess(status){\n            requestInProgress = false;\n            var status = resolveStatus(permission, status[permission]);\n            successCallback(status);\n            var statuses = {};\n            statuses[permission] = status;\n            Diagnostic._onPermissionRequestComplete(statuses);\n            updateFirstRequestedPermissions([permission]);\n        }\n\n        function onError(error){\n            requestInProgress = false;\n            errorCallback(error);\n        }\n\n        requestInProgress = true;\n        return cordova.exec(\n            onSuccess,\n            onError,\n            'Diagnostic',\n            'requestRuntimePermission',\n            [permission]);\n    };\n\n    /**\n     * Requests app to be granted authorisation for multiple runtime permissions.\n     * Note: this is intended for Android 6 / API 23 and above. Calling on Android 5 / API 22 and below will have no effect as the permissions are already granted at installation time.\n     *\n     * @param {Function} successCallback - function to call on successful request for runtime permissions.\n     * This callback function is passed a single object parameter which defines a key/value map, where the key is the permission to request defined as a value in cordova.plugins.diagnostic.permission, and the value is the resulting authorisation status of that permission as a value in cordova.plugins.diagnostic.permissionStatus.\n     * @param {Function} errorCallback - function to call on failure to request authorisation.\n     * This callback function is passed a single string parameter containing the error message.\n     * @param {Array} permissions - permissions to request authorisation for, defined as values in cordova.plugins.diagnostic.permission\n     */\n    Diagnostic.requestRuntimePermissions = function(successCallback, errorCallback, permissions){\n        if(!checkForInvalidPermissions(permissions, errorCallback)) return;\n\n        if(requestInProgress){\n            return onError(\"A runtime permissions request is already in progress\");\n        }\n\n        function onSuccess(statuses){\n            requestInProgress = false;\n            for(var permission in statuses){\n                statuses[permission] = resolveStatus(permission, statuses[permission]);\n            }\n            successCallback(statuses);\n            Diagnostic._onPermissionRequestComplete(statuses);\n            updateFirstRequestedPermissions(permissions);\n        }\n\n        function onError(error){\n            requestInProgress = false;\n            errorCallback(error);\n        }\n\n        requestInProgress = true;\n        return cordova.exec(\n            onSuccess,\n            onError,\n            'Diagnostic',\n            'requestRuntimePermissions',\n            [permissions]);\n\n    };\n\n    /**\n     * Indicates if the plugin is currently requesting a runtime permission via the native API.\n     * Note that only one request can be made concurrently because the native API cannot handle concurrent requests,\n     * so the plugin will invoke the error callback if attempting to make more than one simultaneous request.\n     * Multiple permission requests should be grouped into a single call since the native API is setup to handle batch requests of multiple permission groups.\n     *\n     * @return {boolean} true if a permission request is currently in progress.\n     */\n    Diagnostic.isRequestingPermission = function(){\n        return requestInProgress;\n    };\n\n    /**\n     * Registers a function to be called when a runtime permission request has completed.\n     * Pass in a falsey value to de-register the currently registered function.\n     *\n     * @param {Function} successCallback -  The callback which will be called when a runtime permission request has completed.\n     * This callback function is passed a single object parameter which defines a key/value map, where the key is the permission requested (defined as a value in cordova.plugins.diagnostic.permission) and the value is the resulting authorisation status of that permission as a value in cordova.plugins.diagnostic.permissionStatus.\n     */\n    Diagnostic.registerPermissionRequestCompleteHandler = function(successCallback) {\n        Diagnostic._onPermissionRequestComplete = successCallback || function(){};\n    };\n\n\n    /************\n     * Location *\n     ************/\n\n    /**\n     * Checks if location is available for use by the app.\n     * On Android, this returns true if Location Mode is enabled and any mode is selected (e.g. Battery saving, Device only, High accuracy)\n     * AND if the app is authorised to use location.\n     *\n     * @param {Function} successCallback - The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if location is available for use.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isLocationAvailable = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isLocationAvailable',\n            []);\n    };\n\n    /**\n     * Checks if the device location setting is enabled.\n     * On Android, this returns true if Location Mode is enabled and any mode is selected (e.g. Battery saving, Device only, High accuracy)\n     *\n     * @param {Function} successCallback - The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if location setting is enabled.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isLocationEnabled = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isLocationEnabled',\n            []);\n    };\n\n    /**\n     * Checks if high-accuracy locations are available to the app from GPS hardware.\n     * Returns true if Location mode is enabled and is set to \"Device only\" or \"High accuracy\"\n     * AND if the app is authorised to use location.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if high-accuracy GPS-based location is available.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isGpsLocationAvailable = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isGpsLocationAvailable',\n            []);\n    };\n\n    /**\n     * Checks if the device location setting is set to return high-accuracy locations from GPS hardware.\n     * Returns true if Location mode is enabled and is set to either:\n     * Device only = GPS hardware only (high accuracy)\n     * High accuracy = GPS hardware, network triangulation and Wifi network IDs (high and low accuracy)\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if device setting is set to return high-accuracy GPS-based location.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isGpsLocationEnabled = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isGpsLocationEnabled',\n            []);\n    };\n\n    /**\n     * Checks if low-accuracy locations are available to the app from network triangulation/WiFi access points.\n     * Returns true if Location mode is enabled and is set to \"Battery saving\" or \"High accuracy\"\n     * AND if the app is authorised to use location.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if low-accuracy network-based location is available.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isNetworkLocationAvailable = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isNetworkLocationAvailable',\n            []);\n    };\n\n    /**\n     * Checks if the device location setting is set to return low-accuracy locations from network triangulation/WiFi access points.\n     * Returns true if Location mode is enabled and is set to either:\n     * Battery saving = network triangulation and Wifi network IDs (low accuracy)\n     * High accuracy = GPS hardware, network triangulation and Wifi network IDs (high and low accuracy)\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if device setting is set to return low-accuracy network-based location.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isNetworkLocationEnabled = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isNetworkLocationEnabled',\n            []);\n    };\n\n    /**\n     * Returns the current location mode setting for the device.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single string parameter defined as a constant in `cordova.plugins.diagnostic.locationMode`.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getLocationMode = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'getLocationMode',\n            []);\n    };\n\n    /**\n     * Switches to the Location page in the Settings app\n     */\n    Diagnostic.switchToLocationSettings = function() {\n        return cordova.exec(null,\n            null,\n            'Diagnostic',\n            'switchToLocationSettings',\n            []);\n    };\n\n    /**\n     * Requests location authorization for the application.\n     * Note: this is intended for Android 6 / API 23 and above. Calling on Android 5 / API 22 and below will have no effect as the permissions are already granted at installation time.\n     * @param {Function} successCallback - function to call on successful request for runtime permissions.\n     * This callback function is passed a single string parameter which defines the resulting authorisation status as a value in cordova.plugins.diagnostic.permissionStatus.\n     * @param {Function} errorCallback - function to call on failure to request authorisation.\n     */\n    Diagnostic.requestLocationAuthorization = function(successCallback, errorCallback){\n        function onSuccess(statuses){\n            successCallback(combineLocationStatuses(statuses));\n        }\n        Diagnostic.requestRuntimePermissions(onSuccess, errorCallback, [\n            Diagnostic.permission.ACCESS_COARSE_LOCATION,\n            Diagnostic.permission.ACCESS_FINE_LOCATION\n        ]);\n    };\n\n    /**\n     * Returns the location authorization status for the application.\n     * Note: this is intended for Android 6 / API 23 and above. Calling on Android 5 / API 22 and below will always return GRANTED status as permissions are already granted at installation time.\n     * @param {Function} successCallback - function to call on successful request for runtime permissions status.\n     * This callback function is passed a single string parameter which defines the current authorisation status as a value in cordova.plugins.diagnostic.permissionStatus.\n     * @param {Function} errorCallback - function to call on failure to request authorisation status.\n     */\n    Diagnostic.getLocationAuthorizationStatus = function(successCallback, errorCallback){\n        function onSuccess(statuses){\n            successCallback(combineLocationStatuses(statuses));\n        }\n        Diagnostic.getPermissionsAuthorizationStatus(onSuccess, errorCallback, [\n            Diagnostic.permission.ACCESS_COARSE_LOCATION,\n            Diagnostic.permission.ACCESS_FINE_LOCATION\n        ]);\n    };\n\n    /**\n     * Checks if the application is authorized to use location.\n     * Note: this is intended for Android 6 / API 23 and above. Calling on Android 5 / API 22 and below will always return TRUE as permissions are already granted at installation time.\n     * @param {Function} successCallback - function to call on successful request for runtime permissions status.\n     * This callback function is passed a single boolean parameter which is TRUE if the app currently has runtime authorisation to use location.\n     * @param {Function} errorCallback - function to call on failure to request authorisation status.\n     */\n    Diagnostic.isLocationAuthorized = function(successCallback, errorCallback){\n        function onSuccess(status){\n            successCallback(status == Diagnostic.permissionStatus.GRANTED);\n        }\n        Diagnostic.getLocationAuthorizationStatus(onSuccess, errorCallback);\n    };\n\n    /**\n     * Registers a function to be called when a change in Location state occurs.\n     * On Android, this occurs when the Location Mode is changed.\n     * Pass in a falsey value to de-register the currently registered function.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the Location state changes.\n     * This callback function is passed a single string parameter defined as a constant in `cordova.plugins.diagnostic.locationMode`.\n     */\n    Diagnostic.registerLocationStateChangeHandler = function(successCallback) {\n        Diagnostic._onLocationStateChange = successCallback || function(){};\n    };\n\n    /************\n     * WiFi     *\n     ************/\n\n    /**\n     * Checks if Wifi is enabled.\n     * On Android this returns true if the WiFi setting is set to enabled.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if WiFi is enabled.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isWifiAvailable = Diagnostic.isWifiEnabled = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'isWifiAvailable',\n            []);\n    };\n\n    /**\n     * Switches to the WiFi page in the Settings app\n     */\n    Diagnostic.switchToWifiSettings = function() {\n        return cordova.exec(null,\n            null,\n            'Diagnostic',\n            'switchToWifiSettings',\n            []);\n    };\n\n    /**\n     * Switches to the wireless settings page in the Settings app.\n     * Allows configuration of wireless controls such as Wi-Fi, Bluetooth and Mobile networks.\n     */\n    Diagnostic.switchToWirelessSettings = function() {\n        return cordova.exec(null,\n            null,\n            'Diagnostic',\n            'switchToWirelessSettings',\n            []);\n    };\n\n    /**\n     * Switches to the nfc settings page in the Settings app\n     */\n    Diagnostic.switchToNFCSettings = function() {\n        return cordova.exec(null,\n            null,\n            'Diagnostic',\n            'switchToNFCSettings',\n            []);\n    };\n\n    /**\n     * Enables/disables WiFi on the device.\n     *\n     * @param {Function} successCallback - function to call on successful setting of WiFi state\n     * @param {Function} errorCallback - function to call on failure to set WiFi state.\n     * This callback function is passed a single string parameter containing the error message.\n     * @param {Boolean} state - WiFi state to set: TRUE for enabled, FALSE for disabled.\n     */\n    Diagnostic.setWifiState = function(successCallback, errorCallback, state) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'setWifiState',\n            [state]);\n    };\n\n    /************\n     * Camera   *\n     ************/\n\n    /**\n     * Checks if camera is usable: both present and authorised for use.\n     *\n     * @param {Object} params - (optional) parameters:\n     *  - {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if camera is present and authorized for use.\n     *  - {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     *  - {Boolean} externalStorage - (Android only) If true, checks permission for READ_EXTERNAL_STORAGE in addition to CAMERA run-time permission.\n     *  cordova-plugin-camera@2.2+ requires both of these permissions. Defaults to true.\n     */\n    Diagnostic.isCameraAvailable = function(params) {\n        params = params || {};\n        if (typeof arguments[0]  === \"function\") {\n            console.warn('The API signature \"cordova.plugins.diagnostic.isCameraAvailable(successCallback, errorCallback)\" is deprecated in favour of \"cordova.plugins.diagnostic.isCameraAvailable(params)\". See documentation for details.');\n            params = {\n                successCallback: arguments[0],\n                errorCallback: arguments[1]\n            };\n        }\n\n        params.successCallback = params.successCallback || function(){};\n        Diagnostic.isCameraPresent(function(isPresent){\n            if(isPresent){\n                Diagnostic.isCameraAuthorized(params);\n            }else{\n                params.successCallback(!!isPresent);\n            }\n        },params.errorCallback);\n    };\n\n    /**\n     * Checks if camera hardware is present on device.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if camera is present\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isCameraPresent = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isCameraPresent',\n            []);\n    };\n\n    /**\n     * Requests authorisation for runtime permissions to use the camera.\n     * Note: this is intended for Android 6 / API 23 and above. Calling on Android 5 / API 22 and below will have no effect as the permissions are already granted at installation time.\n     * @param {Object} params - (optional) parameters:\n     *  - {Function} successCallback - function to call on successful request for runtime permissions.\n     * This callback function is passed a single string parameter which defines the resulting authorisation status as a value in cordova.plugins.diagnostic.permissionStatus.\n     *  - {Function} errorCallback - function to call on failure to request authorisation.\n     *  - {Boolean} externalStorage - (Android only) If true, requests permission for READ_EXTERNAL_STORAGE in addition to CAMERA run-time permission.\n     *  cordova-plugin-camera@2.2+ requires both of these permissions. Defaults to true.\n     */\n    Diagnostic.requestCameraAuthorization = function(params){\n        params = params || {};\n        if (typeof arguments[0]  === \"function\") {\n            console.warn('The API signature \"cordova.plugins.diagnostic.requestCameraAuthorization(successCallback, errorCallback)\" is deprecated in favour of \"cordova.plugins.diagnostic.requestCameraAuthorization(params)\". See documentation for details.');\n            params = {\n                successCallback: arguments[0],\n                errorCallback: arguments[1]\n            };\n        }\n\n        var permissions = [Diagnostic.permission.CAMERA];\n        if(params.externalStorage !== false){\n            permissions.push(Diagnostic.permission.READ_EXTERNAL_STORAGE);\n        }\n\n        params.successCallback = params.successCallback || function(){};\n        var onSuccess = function(statuses){\n            params.successCallback(numberOfKeys(statuses) > 1 ? combineCameraStatuses(statuses): statuses[Diagnostic.permission.CAMERA]);\n        };\n        Diagnostic.requestRuntimePermissions(onSuccess, params.errorCallback, permissions);\n    };\n\n    /**\n     * Returns the authorisation status for runtime permissions to use the camera.\n     * Note: this is intended for Android 6 / API 23 and above. Calling on Android 5 / API 22 and below will always return GRANTED status as permissions are already granted at installation time.\n     * @param {Object} params - (optional) parameters:\n     *  - {Function} successCallback - function to call on successful request for runtime permissions status.\n     * This callback function is passed a single string parameter which defines the current authorisation status as a value in cordova.plugins.diagnostic.permissionStatus.\n     *  - {Function} errorCallback - function to call on failure to request authorisation status.\n     *  - {Boolean} externalStorage - (Android only) If true, checks permission for READ_EXTERNAL_STORAGE in addition to CAMERA run-time permission.\n     *  cordova-plugin-camera@2.2+ requires both of these permissions. Defaults to true.\n     */\n    Diagnostic.getCameraAuthorizationStatus = function(params){\n        params = params || {};\n        if (typeof arguments[0]  === \"function\") {\n            console.warn('The API signature \"cordova.plugins.diagnostic.getCameraAuthorizationStatus(successCallback, errorCallback)\" is deprecated in favour of \"cordova.plugins.diagnostic.getCameraAuthorizationStatus(params)\". See documentation for details.');\n            params = {\n                successCallback: arguments[0],\n                errorCallback: arguments[1]\n            };\n        }\n\n        var permissions = [Diagnostic.permission.CAMERA];\n        if(params.externalStorage !== false){\n            permissions.push(Diagnostic.permission.READ_EXTERNAL_STORAGE);\n        }\n\n        params.successCallback = params.successCallback || function(){};\n        var onSuccess = function(statuses){\n            params.successCallback(numberOfKeys(statuses) > 1 ? combineCameraStatuses(statuses): statuses[Diagnostic.permission.CAMERA]);\n        };\n        Diagnostic.getPermissionsAuthorizationStatus(onSuccess, params.errorCallback, permissions);\n    };\n\n    /**\n     * Checks if the application is authorized to use the camera.\n     * Note: this is intended for Android 6 / API 23 and above. Calling on Android 5 / API 22 and below will always return TRUE as permissions are already granted at installation time.\n     * @param {Object} params - (optional) parameters:\n     *  - {Function} successCallback - function to call on successful request for runtime permissions status.\n     * This callback function is passed a single boolean parameter which is TRUE if the app currently has runtime authorisation to use location.\n     *  - {Function} errorCallback - function to call on failure to request authorisation status.\n     *  - {Boolean} externalStorage - (Android only) If true, checks permission for READ_EXTERNAL_STORAGE in addition to CAMERA run-time permission.\n     *  cordova-plugin-camera@2.2+ requires both of these permissions. Defaults to true.\n     */\n    Diagnostic.isCameraAuthorized = function(params){\n        params = params || {};\n        if (typeof arguments[0]  === \"function\") {\n            console.warn('The API signature \"cordova.plugins.diagnostic.isCameraAuthorized(successCallback, errorCallback)\" is deprecated in favour of \"cordova.plugins.diagnostic.isCameraAuthorized(params)\". See documentation for details.');\n            params = {\n                successCallback: arguments[0],\n                errorCallback: arguments[1]\n            };\n        }\n\n        params.successCallback = params.successCallback || function(){};\n        var onSuccess = function(status){\n            params.successCallback(status == Diagnostic.permissionStatus.GRANTED);\n        };\n\n        Diagnostic.getCameraAuthorizationStatus({\n            successCallback: onSuccess,\n            errorCallback: params.errorCallback,\n            externalStorage: params.externalStorage\n        });\n    };\n\n    /**********************\n     * External storage   *\n     **********************/\n    /**\n     * Requests authorisation for runtime permission to use the external storage.\n     * Note: this is intended for Android 6 / API 23 and above. Calling on Android 5 / API 22 and below will have no effect as the permission is already granted at installation time.\n     * @param {Function} successCallback - function to call on successful request for runtime permission.\n     * This callback function is passed a single string parameter which defines the resulting authorisation status as a value in cordova.plugins.diagnostic.permissionStatus.\n     * @param {Function} errorCallback - function to call on failure to request authorisation.\n     */\n    Diagnostic.requestExternalStorageAuthorization = function(successCallback, errorCallback){\n        Diagnostic.requestRuntimePermission(successCallback, errorCallback, Diagnostic.permission.READ_EXTERNAL_STORAGE);\n    };\n\n    /**\n     * Returns the authorisation status for runtime permission to use the external storage.\n     * Note: this is intended for Android 6 / API 23 and above. Calling on Android 5 / API 22 and below will always return GRANTED status as permission is already granted at installation time.\n     * @param {Function} successCallback - function to call on successful request for runtime permission status.\n     * This callback function is passed a single string parameter which defines the current authorisation status as a value in cordova.plugins.diagnostic.permissionStatus.\n     * @param {Function} errorCallback - function to call on failure to request authorisation status.\n     */\n    Diagnostic.getExternalStorageAuthorizationStatus = function(successCallback, errorCallback){\n        Diagnostic.getPermissionAuthorizationStatus(successCallback, errorCallback, Diagnostic.permission.READ_EXTERNAL_STORAGE);\n    };\n\n    /**\n     * Checks if the application is authorized to use external storage.\n     * Note: this is intended for Android 6 / API 23 and above. Calling on Android 5 / API 22 and below will always return TRUE as permissions are already granted at installation time.\n     * @param {Function} successCallback - function to call on successful request for runtime permissions status.\n     * This callback function is passed a single boolean parameter which is TRUE if the app currently has runtime authorisation to external storage.\n     * @param {Function} errorCallback - function to call on failure to request authorisation status.\n     */\n    Diagnostic.isExternalStorageAuthorized = function(successCallback, errorCallback){\n        function onSuccess(status){\n            successCallback(status == Diagnostic.permissionStatus.GRANTED);\n        }\n        Diagnostic.getExternalStorageAuthorizationStatus(onSuccess, errorCallback);\n    };\n\n    /**\n     * Returns details of external SD card(s): absolute path, is writable, free space\n     * @param {Function} successCallback - function to call on successful request for external SD card details.\n     * This callback function is passed a single argument which is an array consisting of an entry for each external storage location found.\n     * Each array entry is an object with the following keys:\n     * - {String} path - absolute path to the storage location\n     * - {String} filePath - absolute path prefixed with file protocol for use with cordova-plugin-file\n     * - {Boolean} canWrite - true if the location is writable\n     * - {Integer} freeSpace - number of bytes of free space on the device on which the storage locaiton is mounted.\n     * - {String} type - indicates the type of storage location: either \"application\" if the path is an Android application sandbox path or \"root\" if the path is the device root.\n     * @param {Function} errorCallback - function to call on failure to request authorisation status.\n     */\n    Diagnostic.getExternalSdCardDetails = function(successCallback, errorCallback){\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'getExternalSdCardDetails',\n            []);\n    };\n\n\n    /***************\n     * Bluetooth   *\n     ***************/\n\n    /**\n     * Checks if Bluetooth is available to the app.\n     * Returns true if the device has Bluetooth capabilities and if so that Bluetooth is switched on\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if Bluetooth is available.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isBluetoothAvailable = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isBluetoothAvailable',\n            []);\n    };\n\n    /**\n     * Checks if the device setting for Bluetooth is switched on.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if Bluetooth is switched on.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isBluetoothEnabled = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isBluetoothEnabled',\n            []);\n    };\n\n    /**\n     * Enables/disables Bluetooth on the device.\n     *\n     * @param {Function} successCallback - function to call on successful setting of Bluetooth state\n     * @param {Function} errorCallback - function to call on failure to set Bluetooth state.\n     * This callback function is passed a single string parameter containing the error message.\n     * @param {Boolean} state - Bluetooth state to set: TRUE for enabled, FALSE for disabled.\n     */\n    Diagnostic.setBluetoothState = function(successCallback, errorCallback, state) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'setBluetoothState',\n            [state]);\n    };\n\n    /**\n     * Returns current state of Bluetooth hardware on the device.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single string parameter defined as a constant in `cordova.plugins.diagnostic.bluetoothState`.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getBluetoothState = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'getBluetoothState',\n            []);\n    };\n\n    /**\n     * Registers a listener function to call when the state of Bluetooth hardware changes.\n     * Pass in a falsey value to de-register the currently registered function.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the state of Bluetooth hardware changes.\n     * This callback function is passed a single string parameter defined as a constant in `cordova.plugins.diagnostic.bluetoothState`.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.registerBluetoothStateChangeHandler = function(successCallback, errorCallback) {\n        cordova.exec(\n            function(){\n                Diagnostic._onBluetoothStateChange = successCallback || function(){};\n            },\n            errorCallback,\n            'Diagnostic',\n            'initializeBluetoothListener',\n            []\n        );\n    };\n\n\n    /**\n     * Checks if the device has Bluetooth capabilities.\n     * See http://developer.android.com/guide/topics/connectivity/bluetooth.html.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if device has Bluetooth capabilities.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.hasBluetoothSupport = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'hasBluetoothSupport', []);\n    };\n\n    /**\n     * Checks if the device has Bluetooth Low Energy (LE) capabilities.\n     * See http://developer.android.com/guide/topics/connectivity/bluetooth-le.html.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if device has Bluetooth LE capabilities.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.hasBluetoothLESupport = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'hasBluetoothLESupport', []);\n    };\n\n    /**\n     * Checks if the device has Bluetooth Low Energy (LE) capabilities.\n     * See http://developer.android.com/guide/topics/connectivity/bluetooth-le.html.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if device has Bluetooth LE capabilities.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.hasBluetoothLESupport = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'hasBluetoothLESupport', []);\n    };\n\n    /**\n     * Checks if the device has Bluetooth Low Energy (LE) peripheral capabilities.\n     * See http://developer.android.com/guide/topics/connectivity/bluetooth-le.html#roles.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if device has Bluetooth LE peripheral capabilities.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.hasBluetoothLEPeripheralSupport = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'hasBluetoothLEPeripheralSupport', []);\n    };\n\n    /**\n     * Switches to the Bluetooth page in the Settings app\n     */\n    Diagnostic.switchToBluetoothSettings = function() {\n        return cordova.exec(null,\n            null,\n            'Diagnostic',\n            'switchToBluetoothSettings',\n            []);\n    };\n\n\n    /*************\n     * Mobile Data\n     *************/\n\n    /**\n     * Switches to the Mobile Data page in the Settings app\n     */\n    Diagnostic.switchToMobileDataSettings = function() {\n        return cordova.exec(null,\n            null,\n            'Diagnostic',\n            'switchToMobileDataSettings',\n            []);\n    };\n\n\n    /***************************\n     * Microphone / Record Audio\n     ***************************/\n\n    /**\n     * Checks if the application is authorized to use the microphone for recording audio.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if access to microphone is authorized.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isMicrophoneAuthorized = function(successCallback, errorCallback) {\n        function onSuccess(status){\n            successCallback(status == Diagnostic.permissionStatus.GRANTED);\n        }\n        Diagnostic.getMicrophoneAuthorizationStatus(onSuccess, errorCallback);\n    };\n\n    /**\n     * Returns the authorization status for the application to use the microphone for recording audio.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter which indicates the authorization status.\n     * Possible values are: \"unknown\", \"denied\", \"not_determined\", \"authorized\"\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getMicrophoneAuthorizationStatus = function(successCallback, errorCallback) {\n        Diagnostic.getPermissionAuthorizationStatus(successCallback, errorCallback, Diagnostic.permission.RECORD_AUDIO);\n    };\n\n    /**\n     * Requests access to microphone if authorization was never granted nor denied, will only return access status otherwise.\n     *\n     * @param {Function} successCallback - The callback which will be called when authorization request is successful.\n     * @param {Function} errorCallback - The callback which will be called when an error occurs.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.requestMicrophoneAuthorization = function(successCallback, errorCallback) {\n        Diagnostic.requestRuntimePermission(successCallback, errorCallback, Diagnostic.permission.RECORD_AUDIO);\n    };\n\n    /*************\n     * Contacts\n     *************/\n\n    /**\n     *Checks if the application is authorized to use contacts (address book).\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if access to microphone is authorized.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isContactsAuthorized = function(successCallback, errorCallback) {\n        function onSuccess(status){\n            successCallback(status == Diagnostic.permissionStatus.GRANTED);\n        }\n        Diagnostic.getContactsAuthorizationStatus(onSuccess, errorCallback);\n    };\n\n    /**\n     * Returns the contacts (address book) authorization status for the application.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter which indicates the authorization status.\n     * Possible values are: \"unknown\", \"denied\", \"not_determined\", \"authorized\"\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getContactsAuthorizationStatus = function(successCallback, errorCallback) {\n        Diagnostic.getPermissionAuthorizationStatus(successCallback, errorCallback, Diagnostic.permission.READ_CONTACTS);\n    };\n\n    /**\n     *  Requests contacts (address book) authorization for the application.\n     *  Should only be called if authorization status is NOT_REQUESTED. Calling it when in any other state will have no effect.\n     *\n     * @param {Function} successCallback - The callback which will be called when authorization request is successful.\n     * @param {Function} errorCallback - The callback which will be called when an error occurs.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.requestContactsAuthorization = function(successCallback, errorCallback) {\n        Diagnostic.requestRuntimePermission(successCallback, errorCallback, Diagnostic.permission.READ_CONTACTS);\n    };\n\n    /*************\n     * Calendar\n     *************/\n\n    /**\n     *Checks if the application is authorized to use calendar.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if access to microphone is authorized.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isCalendarAuthorized = function(successCallback, errorCallback) {\n        function onSuccess(status){\n            successCallback(status == Diagnostic.permissionStatus.GRANTED);\n        }\n        Diagnostic.getCalendarAuthorizationStatus(onSuccess, errorCallback);\n    };\n\n    /**\n     * Returns the calendar authorization status for the application.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter which indicates the authorization status.\n     * Possible values are: \"unknown\", \"denied\", \"not_determined\", \"authorized\"\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getCalendarAuthorizationStatus = function(successCallback, errorCallback) {\n        Diagnostic.getPermissionAuthorizationStatus(successCallback, errorCallback, Diagnostic.permission.READ_CALENDAR);\n    };\n\n    /**\n     *  Requests calendar authorization for the application.\n     *  Should only be called if authorization status is NOT_REQUESTED. Calling it when in any other state will have no effect.\n     *\n     * @param {Function} successCallback - The callback which will be called when authorization request is successful.\n     * @param {Function} errorCallback - The callback which will be called when an error occurs.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.requestCalendarAuthorization = function(successCallback, errorCallback) {\n        Diagnostic.requestRuntimePermission(successCallback, errorCallback, Diagnostic.permission.READ_CALENDAR);\n    };\n\n    /*************\n     * NFC\n     *************/\n\n    /**\n     * Checks if NFC hardware is present on device.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if NFC is present\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isNFCPresent = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isNFCPresent',\n            []);\n    };\n\n    /**\n     * Checks if the device setting for NFC is switched on.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if NFC is switched on.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isNFCEnabled = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isNFCEnabled',\n            []);\n    };\n\n    /**\n     * Checks if NFC is available to the app.\n     * Returns true if the device has NFC capabilities and if so that NFC is switched on.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if NFC is available.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isNFCAvailable = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isNFCAvailable',\n            []);\n    };\n\n    /**\n     * Registers a function to be called when a change in NFC state occurs.\n     * Pass in a falsey value to de-register the currently registered function.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the NFC state changes.\n     * This callback function is passed a single string parameter defined as a constant in `cordova.plugins.diagnostic.NFCState`.\n     */\n    Diagnostic.registerNFCStateChangeHandler = function(successCallback) {\n        Diagnostic._onNFCStateChange = successCallback || function(){};\n    };\n\n\n    /**************\n     * Constructor\n     **************/\n    getFirstRequestedPermissions();\n\n    return Diagnostic;\n});\nmodule.exports = new Diagnostic();\n","/home/travis/build/npmtest/node-npmtest-cordova.plugins.diagnostic/node_modules/cordova.plugins.diagnostic/www/ios/diagnostic.js":"/**\n *  Diagnostic plugin for iOS\n *\n *  Copyright (c) 2015 Working Edge Ltd.\n *  Copyright (c) 2012 AVANTIC ESTUDIO DE INGENIEROS\n **/\nvar Diagnostic = (function(){\n\n    /********************\n     * Internal functions\n     ********************/\n\n    function ensureBoolean(callback){\n        return function(result){\n            callback(!!result);\n        }\n    }\n\n\n\n    /********************\n     * Public properties\n     ********************/\n    var Diagnostic = {};\n\n    /**\n     * Permission states\n     * @type {object}\n     */\n    Diagnostic.permissionStatus = {\n        \"NOT_REQUESTED\": \"not_determined\", // App has not yet requested this permission\n        \"DENIED\": \"denied\", // User denied access to this permission\n        \"RESTRICTED\": \"restricted\", // Permission is unavailable and user cannot enable it.  For example, when parental controls are in effect for the current user.\n        \"GRANTED\": \"authorized\", //  User granted access to this permission\n        \"GRANTED_WHEN_IN_USE\": \"authorized_when_in_use\" //  User granted access use location permission only when app is in use\n    };\n\n    Diagnostic.locationAuthorizationMode = {\n        \"ALWAYS\": \"always\",\n        \"WHEN_IN_USE\": \"when_in_use\"\n    };\n\n    Diagnostic.bluetoothState = {\n        \"UNKNOWN\": \"unknown\",\n        \"RESETTING\": \"resetting\",\n        \"UNSUPPORTED\": \"unsupported\",\n        \"UNAUTHORIZED\": \"unauthorized\",\n        \"POWERED_OFF\": \"powered_off\",\n        \"POWERED_ON\": \"powered_on\"\n    };\n\n    // Placeholder listeners\n    Diagnostic._onBluetoothStateChange =\n        Diagnostic._onLocationStateChange = function(){};\n\n    /**********************\n     *\n     * Public API functions\n     *\n     **********************/\n\n    /***********\n     * General\n     ***********/\n\n    /**\n     * Switch to settings app. Opens settings page for this app.\n     *\n     * @param {Function} successCallback - The callback which will be called when switch to settings is successful.\n     * @param {Function} errorCallback - The callback which will be called when switch to settings encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     * This works only on iOS 8+. iOS 7 and below will invoke the errorCallback.\n     */\n    Diagnostic.switchToSettings = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'switchToSettings',\n            []);\n    };\n\n    /************\n     * Location *\n     ************/\n\n\n    /**\n     * Checks if location is available for use by the app.\n     * On iOS this returns true if both the device setting for Location Services is ON AND the application is authorized to use location.\n     * When location is enabled, the locations returned are by a mixture GPS hardware, network triangulation and Wifi network IDs.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if location is available for use.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isLocationAvailable = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isLocationAvailable',\n            []);\n    };\n\n    /**\n     * Checks if the device location setting is enabled.\n     * Returns true if Location Services is enabled.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if Location Services is enabled.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isLocationEnabled = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isLocationEnabled',\n            []);\n    };\n\n\n    /**\n     * Checks if the application is authorized to use location.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if application is authorized to use location either \"when in use\" (only in foreground) OR \"always\" (foreground and background).\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isLocationAuthorized = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isLocationAuthorized',\n            []);\n    };\n\n    /**\n     * Returns the location authorization status for the application.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter which indicates the location authorization status as a constant in `cordova.plugins.diagnostic.permissionStatus`.\n     * Possible values are:\n     * `cordova.plugins.diagnostic.permissionStatus.NOT_REQUESTED`\n     * `cordova.plugins.diagnostic.permissionStatus.DENIED`\n     * `cordova.plugins.diagnostic.permissionStatus.GRANTED`\n     * `cordova.plugins.diagnostic.permissionStatus.GRANTED_WHEN_IN_USE`\n     * Note that `GRANTED` indicates the app is always granted permission (even when in background).\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getLocationAuthorizationStatus = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'getLocationAuthorizationStatus',\n            []);\n    };\n\n    /**\n     * Requests location authorization for the application.\n     * Authorization can be requested to use location either \"when in use\" (only in foreground) or \"always\" (foreground and background).\n     * Should only be called if authorization status is NOT_REQUESTED. Calling it when in any other state will have no effect.\n     *\n     * @param {Function} successCallback - Invoked in response to the user's choice in the permission dialog.\n     * It is passed a single string parameter which defines the resulting authorisation status as a constant in `cordova.plugins.diagnostic.permissionStatus`.\n     * Possible values are:\n     * `cordova.plugins.diagnostic.permissionStatus.DENIED`\n     * `cordova.plugins.diagnostic.permissionStatus.GRANTED`\n     * `cordova.plugins.diagnostic.permissionStatus.GRANTED_WHEN_IN_USE`\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     * @param {String} mode - (optional) location authorization mode as a constant in `cordova.plugins.diagnostic.locationAuthorizationMode`.\n     * If not specified, defaults to `cordova.plugins.diagnostic.locationAuthorizationMode.WHEN_IN_USE`.\n     */\n    Diagnostic.requestLocationAuthorization = function(successCallback, errorCallback, mode) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'requestLocationAuthorization',\n            [mode && mode === Diagnostic.locationAuthorizationMode.ALWAYS]);\n    };\n\n    /**\n     * Registers a function to be called when a change in Location state occurs.\n     * On iOS, this occurs when location authorization status is changed.\n     * This can be triggered either by the user's response to a location permission authorization dialog,\n     * by the user turning on/off Location Services,\n     * or by the user changing the Location authorization state specifically for your app.\n     * Pass in a falsey value to de-register the currently registered function.\n     *\n     * @param {Function} successCallback -  The callback which will be called when the Location state changes.\n     * This callback function is passed a single string parameter indicating the new location authorisation status as a constant in `cordova.plugins.diagnostic.permissionStatus`.\n     */\n    Diagnostic.registerLocationStateChangeHandler = function(successCallback) {\n        Diagnostic._onLocationStateChange = successCallback || function(){};\n    };\n\n    /************\n     * Camera   *\n     ************/\n\n    /**\n     * Checks if camera is enabled for use.\n     * On iOS this returns true if both the device has a camera AND the application is authorized to use it.\n     *\n     * @param {Object} params - (optional) parameters:\n     *  - {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if camera is present and authorized for use.\n     *  - {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isCameraAvailable = function(params) {\n        params = params || {};\n        if (typeof arguments[0]  === \"function\") {\n            console.warn('The API signature \"cordova.plugins.diagnostic.isCameraAvailable(successCallback, errorCallback)\" is deprecated in favour of \"cordova.plugins.diagnostic.isCameraAvailable(params)\". See documentation for details.');\n            params = {\n                successCallback: arguments[0],\n                errorCallback: arguments[1]\n            };\n        }\n\n        params.successCallback = params.successCallback || function(){};\n        return cordova.exec(ensureBoolean(params.successCallback),\n            params.errorCallback,\n            'Diagnostic',\n            'isCameraAvailable',\n            []);\n    };\n\n    /**\n     * Checks if camera hardware is present on device.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if camera is present\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isCameraPresent = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isCameraPresent',\n            []);\n    };\n\n\n    /**\n     * Checks if the application is authorized to use the camera.\n     *\n     * @param {Object} params - (optional) parameters:\n     *  - {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if camera is authorized for use.\n     *   - {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isCameraAuthorized = function(params) {\n        params = params || {};\n        if (typeof arguments[0]  === \"function\") {\n            console.warn('The API signature \"cordova.plugins.diagnostic.isCameraAuthorized(successCallback, errorCallback)\" is deprecated in favour of \"cordova.plugins.diagnostic.isCameraAuthorized(params)\". See documentation for details.');\n            params = {\n                successCallback: arguments[0],\n                errorCallback: arguments[1]\n            };\n        }\n\n        return cordova.exec(ensureBoolean(params.successCallback),\n            params.errorCallback,\n            'Diagnostic',\n            'isCameraAuthorized',\n            []);\n    };\n\n    /**\n     * Returns the camera authorization status for the application.\n     *\n     * @param {Object} params - (optional) parameters:\n     *  - {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter which indicates the authorization status as a constant in `cordova.plugins.diagnostic.permissionStatus`.\n     *  - {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getCameraAuthorizationStatus = function(params) {\n        params = params || {};\n        if (typeof arguments[0]  === \"function\") {\n            console.warn('The API signature \"cordova.plugins.diagnostic.getCameraAuthorizationStatus(successCallback, errorCallback)\" is deprecated in favour of \"cordova.plugins.diagnostic.getCameraAuthorizationStatus(params)\". See documentation for details.');\n            params = {\n                successCallback: arguments[0],\n                errorCallback: arguments[1]\n            };\n        }\n\n        return cordova.exec(params.successCallback,\n            params.errorCallback,\n            'Diagnostic',\n            'getCameraAuthorizationStatus',\n            []);\n    };\n\n    /**\n     * Requests camera authorization for the application.\n     * Should only be called if authorization status is NOT_REQUESTED. Calling it when in any other state will have no effect.\n     *\n     * @param {Object} params - (optional) parameters:\n     * - {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter indicating whether access to the camera was granted or denied:\n     * `cordova.plugins.diagnostic.permissionStatus.GRANTED` or `cordova.plugins.diagnostic.permissionStatus.DENIED`\n     * - {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.requestCameraAuthorization = function(params){\n        params = params || {};\n        if (typeof arguments[0]  === \"function\") {\n            console.warn('The API signature \"cordova.plugins.diagnostic.requestCameraAuthorization(successCallback, errorCallback)\" is deprecated in favour of \"cordova.plugins.diagnostic.requestCameraAuthorization(params)\". See documentation for details.');\n            params = {\n                successCallback: arguments[0],\n                errorCallback: arguments[1]\n            };\n        }\n\n        params.successCallback = params.successCallback || function(){};\n        return cordova.exec(function(isGranted){\n                params.successCallback(isGranted ? Diagnostic.permissionStatus.GRANTED : Diagnostic.permissionStatus.DENIED);\n            },\n            params.errorCallback,\n            'Diagnostic',\n            'requestCameraAuthorization',\n            []);\n    };\n\n    /**\n     * Checks if the application is authorized to use the Camera Roll in Photos app.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if access to Camera Roll is authorized.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isCameraRollAuthorized = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isCameraRollAuthorized',\n            []);\n    };\n\n    /**\n     * Returns the authorization status for the application to use the Camera Roll in Photos app.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter which indicates the authorization status as a constant in `cordova.plugins.diagnostic.permissionStatus`.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getCameraRollAuthorizationStatus = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'getCameraRollAuthorizationStatus',\n            []);\n    };\n\n    /**\n     * Requests camera roll authorization for the application.\n     * Should only be called if authorization status is NOT_REQUESTED. Calling it when in any other state will have no effect.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter indicating the new authorization status:\n     * `cordova.plugins.diagnostic.permissionStatus.GRANTED` or `cordova.plugins.diagnostic.permissionStatus.DENIED`\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.requestCameraRollAuthorization = function(successCallback, errorCallback) {\n        return cordova.exec(function(status){\n                successCallback(status == \"authorized\" ? Diagnostic.permissionStatus.GRANTED : Diagnostic.permissionStatus.DENIED);\n            },\n            errorCallback,\n            'Diagnostic',\n            'requestCameraRollAuthorization',\n            []);\n    };\n\n    /************\n     * WiFi     *\n     ************/\n\n    /**\n     * Checks if Wi-Fi is connected.\n     * On iOS this returns true if the WiFi setting is set to enabled AND the device is connected to a network by WiFi.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if device is connected by WiFi.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isWifiAvailable = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isWifiAvailable',\n            []);\n    };\n\n    /**\n     * Checks if Wifi is enabled.\n     * On iOS this returns true if the WiFi setting is set to enabled (regardless of whether it's connected to a network).\n     *\n     * @param {Function} successCallback -  The callback which will be called when the operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if WiFi is enabled.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isWifiEnabled = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'isWifiEnabled',\n            []);\n    };\n\n    /***************\n     * Bluetooth   *\n     ***************/\n\n    /**\n     * Checks if the device has Bluetooth LE capabilities and if so that Bluetooth is switched on\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if device has Bluetooth LE and Bluetooth is switched on.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isBluetoothAvailable = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isBluetoothAvailable',\n            []);\n    };\n\n    /**\n     * Returns the state of Bluetooth LE on the device.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter which indicates the Bluetooth state as a constant in `cordova.plugins.diagnostic.bluetoothState`.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getBluetoothState = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'getBluetoothState',\n            []);\n    };\n\n\n    /**\n     * Registers a function to be called when a change in Bluetooth state occurs.\n     * Pass in a falsey value to de-register the currently registered function.\n     *\n     * @param {Function} successCallback - function call when a change in Bluetooth state occurs.\n     * This callback function is passed a single string parameter which indicates the Bluetooth state as a constant in `cordova.plugins.diagnostic.bluetoothState`.\n     * @param {Function} errorCallback -  The callback which will be called when the operation encounters an error.\n     *  This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.registerBluetoothStateChangeHandler = function(successCallback, errorCallback){\n        Diagnostic._onBluetoothStateChange = successCallback || function(){};\n    };\n\n    /**\n     * Requests Bluetooth authorization for the application.\n     * The outcome of the authorization request can be determined by registering a handler using `registerBluetoothStateChangeHandler()`.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is not passed any parameters.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.requestBluetoothAuthorization = function(successCallback, errorCallback) {\n        return cordova.exec(\n            successCallback,\n            errorCallback,\n            'Diagnostic',\n            'requestBluetoothAuthorization',\n            []);\n    };\n\n    /***************************\n     * Microphone / Record Audio\n     ***************************/\n\n    /**\n     * Checks if the application is authorized to use the microphone for recording audio.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if access to microphone is authorized.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isMicrophoneAuthorized = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isMicrophoneAuthorized',\n            []);\n    };\n\n    /**\n     * Returns the authorization status for the application to use the microphone for recording audio.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter which indicates the authorization status as a constant in `cordova.plugins.diagnostic.permissionStatus`.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getMicrophoneAuthorizationStatus = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'getMicrophoneAuthorizationStatus',\n            []);\n    };\n\n    /**\n     * Requests access to microphone if authorization was never granted nor denied, will only return access status otherwise.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter indicating whether access to the microphone was granted or denied:\n     * `cordova.plugins.diagnostic.permissionStatus.GRANTED` or `cordova.plugins.diagnostic.permissionStatus.DENIED`\n     * @param {Function} errorCallback - The callback which will be called when an error occurs.\n     * This callback function is passed a single string parameter containing the error message.\n     * This works only on iOS 7+.\n     */\n    Diagnostic.requestMicrophoneAuthorization = function(successCallback, errorCallback) {\n        return cordova.exec(function(isGranted){\n                successCallback(isGranted ? Diagnostic.permissionStatus.GRANTED : Diagnostic.permissionStatus.DENIED);\n            },\n            errorCallback,\n            'Diagnostic',\n            'requestMicrophoneAuthorization',\n            []);\n    };\n\n    /***********************\n     * Remote Notifications\n     ***********************/\n\n    /**\n     * Checks if remote (push) notifications are enabled.\n     * On iOS 8+, returns true if app is registered for remote notifications AND \"Allow Notifications\" switch is ON AND alert style is not set to \"None\" (i.e. \"Banners\" or \"Alerts\").\n     * On iOS <=7, returns true if app is registered for remote notifications AND alert style is not set to \"None\" (i.e. \"Banners\" or \"Alerts\") - same as isRegisteredForRemoteNotifications().\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if remote (push) notifications are enabled.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isRemoteNotificationsEnabled = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isRemoteNotificationsEnabled',\n            []);\n    };\n\n    /**\n     * Indicates the current setting of notification types for the app in the Settings app.\n     * Note: on iOS 8+, if \"Allow Notifications\" switch is OFF, all types will be returned as disabled.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single object parameter where the key is the notification type and the value is a boolean indicating whether it's enabled:\n     * \"alert\" => alert style is not set to \"None\" (i.e. \"Banners\" or \"Alerts\");\n     * \"badge\" => \"Badge App Icon\" switch is ON;\n     * \"sound\" => \"Sounds\"/\"Alert Sound\" switch is ON.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getRemoteNotificationTypes = function(successCallback, errorCallback) {\n        return cordova.exec(function(sTypes){\n                var oTypes = JSON.parse(sTypes);\n                for(var type in oTypes){\n                    oTypes[type] = parseInt(oTypes[type]) === 1 ;\n                }\n                successCallback(oTypes);\n            },\n            errorCallback,\n            'Diagnostic',\n            'getRemoteNotificationTypes',\n            []);\n    };\n\n    /**\n     * Indicates if the app is registered for remote notifications on the device.\n     * On iOS 8+, returns true if the app is registered for remote notifications and received its device token,\n     * or false if registration has not occurred, has failed, or has been denied by the user.\n     * Note that user preferences for notifications in the Settings app will not affect this.\n     * On iOS <=7, returns true if app is registered for remote notifications AND alert style is not set to \"None\" (i.e. \"Banners\" or \"Alerts\") - same as isRemoteNotificationsEnabled().\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if the device is registered for remote (push) notifications.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isRegisteredForRemoteNotifications = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isRegisteredForRemoteNotifications',\n            []);\n    };\n\n    /*************\n     * Contacts\n     *************/\n\n    /**\n     * Checks if the application is authorized to use contacts (address book).\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if contacts is authorized for use.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isContactsAuthorized = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isAddressBookAuthorized',\n            []);\n    };\n\n    /**\n     * Returns the contacts (address book) authorization status for the application.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter which indicates the authorization status as a constant in `cordova.plugins.diagnostic.permissionStatus`.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getContactsAuthorizationStatus = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'getAddressBookAuthorizationStatus',\n            []);\n    };\n\n    /**\n     * Requests contacts (address book) authorization for the application.\n     * Should only be called if authorization status is NOT_REQUESTED. Calling it when in any other state will have no effect.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter indicating whether access to contacts was granted or denied:\n     * `cordova.plugins.diagnostic.permissionStatus.GRANTED` or `cordova.plugins.diagnostic.permissionStatus.DENIED`\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.requestContactsAuthorization = function(successCallback, errorCallback) {\n        return cordova.exec(function(isGranted){\n                successCallback(isGranted ? Diagnostic.permissionStatus.GRANTED : Diagnostic.permissionStatus.DENIED);\n            },\n            errorCallback,\n            'Diagnostic',\n            'requestAddressBookAuthorization',\n            []);\n    };\n\n    /*****************\n     * Calendar events\n     *****************/\n\n    /**\n     * Checks if the application is authorized to use calendar.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if calendar is authorized for use.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isCalendarAuthorized = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isCalendarAuthorized',\n            []);\n    };\n\n    /**\n     * Returns the calendar event authorization status for the application.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter which indicates the authorization status as a constant in `cordova.plugins.diagnostic.permissionStatus`.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getCalendarAuthorizationStatus = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'getCalendarAuthorizationStatus',\n            []);\n    };\n\n    /**\n     * Requests calendar event authorization for the application.\n     * Should only be called if authorization status is NOT_REQUESTED. Calling it when in any other state will have no effect.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter indicating whether access to calendar was granted or denied:\n     * `cordova.plugins.diagnostic.permissionStatus.GRANTED` or `cordova.plugins.diagnostic.permissionStatus.DENIED`\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.requestCalendarAuthorization = function(successCallback, errorCallback) {\n        return cordova.exec(function(isGranted){\n                successCallback(isGranted ? Diagnostic.permissionStatus.GRANTED : Diagnostic.permissionStatus.DENIED);\n            },\n            errorCallback,\n            'Diagnostic',\n            'requestCalendarAuthorization',\n            []);\n    };\n\n    /*********************\n     * Calendar reminders\n     *********************/\n\n    /**\n     * Checks if the application is authorized to use calendar reminders.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if reminders is authorized for use.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isRemindersAuthorized = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isRemindersAuthorized',\n            []);\n    };\n\n    /**\n     * Returns the calendar event authorization status for the application.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter which indicates the authorization status as a constant in `cordova.plugins.diagnostic.permissionStatus`.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getRemindersAuthorizationStatus = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'getRemindersAuthorizationStatus',\n            []);\n    };\n\n    /**\n     * Requests calendar reminders authorization for the application.\n     * Should only be called if authorization status is NOT_REQUESTED. Calling it when in any other state will have no effect.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter indicating whether access to reminders was granted or denied:\n     * `cordova.plugins.diagnostic.permissionStatus.GRANTED` or `cordova.plugins.diagnostic.permissionStatus.DENIED`\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.requestRemindersAuthorization = function(successCallback, errorCallback) {\n        return cordova.exec(function(isGranted){\n                successCallback(isGranted ? Diagnostic.permissionStatus.GRANTED : Diagnostic.permissionStatus.DENIED);\n            },\n            errorCallback,\n            'Diagnostic',\n            'requestRemindersAuthorization',\n            []);\n    };\n\n    /*********************\n     * Background refresh\n     *********************/\n\n    /**\n     * Returns the background refresh authorization status for the application.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter which indicates the authorization status as a constant in `cordova.plugins.diagnostic.permissionStatus`.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.getBackgroundRefreshStatus = function(successCallback, errorCallback) {\n        return cordova.exec(successCallback,\n            errorCallback,\n            'Diagnostic',\n            'getBackgroundRefreshStatus',\n            []);\n    };\n\n    /**\n     * Checks if the application is authorized for background refresh.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if background refresh is authorized for use.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isBackgroundRefreshAuthorized = function(successCallback, errorCallback) {\n        Diagnostic.getBackgroundRefreshStatus(function(status){\n            successCallback(status === Diagnostic.permissionStatus.GRANTED);\n        }, errorCallback);\n    };\n\n    /*************\n     * Motion\n     *************/\n\n    /**\n     * Checks if motion tracking is available on the current device.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if motion tracking is available on the current device.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isMotionAvailable = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isMotionAvailable',\n            []);\n    };\n\n    /**\n     * Checks if it's possible to determine the outcome of a motion authorization request on the current device.\n     * There's no direct way to determine if authorization was granted or denied, so the Pedometer API must be used to indirectly determine this:\n     * therefore, if the device supports motion tracking but not Pedometer Event Tracking, the outcome of requesting motion detection cannot be determined.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single boolean parameter which is TRUE if it's possible to determine the outcome of a motion authorization request on the current device.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.isMotionRequestOutcomeAvailable = function(successCallback, errorCallback) {\n        return cordova.exec(ensureBoolean(successCallback),\n            errorCallback,\n            'Diagnostic',\n            'isMotionRequestOutcomeAvailable',\n            []);\n    };\n\n    /**\n     * Requests and checks motion authorization for the application:\n     * there is no way to independently request only or check only, so both must be done in one operation.\n     * The native dialog asking user's consent can only be invoked once after the app is installed by calling this function:\n     * once the user has either allowed or denied access, this function will only return the current authorization status\n     * - it is not possible to re-invoke the dialog if the user denied permission in the native dialog;\n     * in this case, you will have to instruct the user how to change motion authorization manually via the Settings app.\n     * When calling this function, the message contained in the `NSMotionUsageDescription` .plist key is displayed to the user;\n     * this plugin provides a default message, but you should override this with your specific reason for requesting access.\n     * If the device doesn't support motion detection, the error callback will be invoked.\n     * There's no direct way to determine if authorization was granted or denied, so the Pedometer API must be used to indirectly determine this:\n     * therefore, if the device supports motion tracking but not Pedometer Event Tracking, the outcome of requesting motion detection cannot be determined.\n     *\n     * @param {Function} successCallback - The callback which will be called when operation is successful.\n     * This callback function is passed a single string parameter indicating the result:\n     * - `cordova.plugins.diagnostic.permissionStatus.GRANTED` - user granted motion authorization\n     * - `cordova.plugins.diagnostic.permissionStatus.DENIED` - user denied authorization\n     * - `cordova.plugins.diagnostic.permissionStatus.RESTRICTED` - user cannot grant motion authorization\n     * - `cordova.plugins.diagnostic.permissionStatus.NOT_DETERMINED` - device does not support Pedometer Event Tracking, so authorization outcome cannot be determined.\n     * - {Function} errorCallback - The callback which will be called when an error occurs. This callback function is passed a single string parameter containing the error message.\n     * @param {Function} errorCallback -  The callback which will be called when operation encounters an error.\n     * This callback function is passed a single string parameter containing the error message.\n     */\n    Diagnostic.requestAndCheckMotionAuthorization = function(successCallback, errorCallback) {\n        return cordova.exec(\n            successCallback,\n            errorCallback,\n            'Diagnostic',\n            'requestAndCheckMotionAuthorization',\n            []);\n    };\n\n    return Diagnostic;\n})();\nmodule.exports = Diagnostic;\n"}